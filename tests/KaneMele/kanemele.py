from __future__ import division
import sys
from numpy import *
from numpy.linalg import *
import matplotlib.pyplot as plt
#from mpl_toolkits.mplot3d import Axes3D

PLOT_EIG = False
WRITE_AMN = True

#Define some useful matrices   
I = eye(2)
sigma_x = array([[0, 1],[1, 0]])
sigma_y = array([[0, -1j],[1j, 0]])
sigma_z = array([[1, 0],[0, -1]])    
GammaA = zeros((5,4,4), dtype=complex)
GammaA[0,:,:] = kron(sigma_x, I)
GammaA[1,:,:] = kron(sigma_z, I)
GammaA[2,:,:] = kron(sigma_y, sigma_x)
GammaA[3,:,:] = kron(sigma_y, sigma_y)
GammaA[4,:,:] = kron(sigma_y, sigma_z)
GammaAB = zeros((5,5,4,4), dtype=complex)
for i in range(5):
    for j in range(5):
        GammaAB[i,j,:,:] = (GammaA[i].dot(GammaA[j]) - GammaA[j].dot(GammaA[i]))/(2*1j)


#This function defines the Hamiltonian matrix of the Kane-Mele model.    
def Ham(a,t,l_nu,l_R,l_SO,k):
    x = k[0]*a/2
    y = sqrt(3)*k[1]*a/2
    d1 = t*(1+2*cos(x)*cos(y))
    d2 = l_nu
    d3 = l_R*(1 - cos(x)*cos(y))
    d4 = -sqrt(3)*l_R*sin(x)*sin(y)

    d12 = -2*t*cos(x)*sin(y)
    d15 = l_SO*(2*sin(2*x) - 4*sin(x)*cos(y))
    d23 = -l_R*cos(x)*sin(y)
    d24 = sqrt(3)*l_R*sin(x)*cos(y)

    return d1*GammaA[0,:,:] + d2*GammaA[1,:,:] + d3*GammaA[2,:,:] + d4*GammaA[3,:,:] + \
            d12*GammaAB[0,1,:,:] + d15*GammaAB[0,4,:,:] + d23*GammaAB[1,2,:,:] + d24*GammaAB[1,3,:,:]
    
if (len(sys.argv)>1):
    N = int(sys.argv[1])
    l_nu = float(sys.argv[2])
else:
    N = 0
    l_nu = 0

#Define parameters
a = 1
t = 1
l_R = 1 #1#0 #1.5 
l_SO = 1

if N==0:
    N1 = 100
    N2 = 100
    l_nu = 1.0 #6  
else:
    N1 = N
    N2 = N

N3 = 1
Ntot = N1*N2*N3
nband = 2
nwannier = 2
nneighbors = 4
#Reciprocal unit cell
Lx = 4*pi/a
Ly = 4*pi/a/sqrt(3)
Lz = 1.


#Create the array of k-points: the mesh of the Brillouin Zone
#Create the correspondence arrays between (i,j,k)-notation (3D) and K-notation (linear)
k_pts = zeros((N1,N2,N3,3))
K_to_ijk = zeros((Ntot,3),dtype = int64)
ijk_to_K = zeros((N1,N2,N3),dtype = int64)
for i in range(N1):
    for j in range(N2):
        for k in range(N3):
            K = i*N2*N3+j*N3+k
            ijk_to_K[i,j,k] = K
            K_to_ijk[K,:] = [i, j, k]
            k_pts[i,j,k,:] = [i*Lx/N1,j*Ly/N2,k*Lz/N3]



#Open mmn file to write stream
mmn=open("kanemele_"+str(l_nu)+"_"+str(N1)+".mmn",'w')
mmn.write("This mmn file was generated by kanemele.py  ")
mmn.write("Ntot = "+ str(Ntot) + " nband = " + str(nband) + "\n")
mmn.write(str(nband) + " " + str(Ntot) + " " + str(nneighbors)+"\n")

#Open amn file to write stream
if WRITE_AMN:
    amn=open("kanemele_"+str(l_nu)+"_"+str(N1)+".amn",'w')
    amn.write("This amn file was generated by kanemele.py  ")
    amn.write("Ntot = "+ str(Ntot) + " nband = " + str(nband) + "\n")
    amn.write(str(nband) + " " + str(Ntot) + " " + str(nwannier)+"\n")

#Define the container array for the eigenvalues of the Hamiltonian
eigs = zeros((N1,N2,N3,4))

#MAIN LOOP
#Go through all points in the Brillouin Zone, and compute the matrix Mmn of overlap
#of the eigenvalues at a k-point and its neighbors
for i in range(N1):
    for j in range(N2):
        for k in range(N3):
            K = ijk_to_K[i,j,k]

            #Fill the list of neighboring points of K in K-notation
            Kpb_list = []
            if(N1>1):
                Kpb_list.append( ijk_to_K[(i+1)%N1,j,k])
                Kpb_list.append( ijk_to_K[(i-1)%N1,j,k])
            if(N2>1):
                Kpb_list.append( ijk_to_K[i,(j+1)%N2,k])
                Kpb_list.append( ijk_to_K[i,(j-1)%N2,k])
            if(N3>1):
                Kpb_list.append( ijk_to_K[i,j,(k+1)%N3])
                Kpb_list.append( ijk_to_K[i,j,(k-1)%N3])

            #Compute the eigenvalues at point K
            wK, vK = eigh(Ham(a,t,l_nu,l_R,l_SO, k_pts[i,j,k,0:2]))
            eigs[i,j,k,:] = wK
            
            #Write eigenvector in amn file
            if WRITE_AMN:
                for mn in range(nband**2):
                    m,n = mod(mn,nband), int(mn/nband)
                    amn.write(str(m+1)+ ' ' + str(n+1) + ' ' + str(K+1) + ' ' + str(real(vK[n,m])) + ' ' + str(-imag(vK[n,m])) +'\n') 

            #Compute the eigenvalues at neighboring points
            for Kpb in Kpb_list:
                iN = K_to_ijk[Kpb,0]
                jN = K_to_ijk[Kpb,1]
                kN = K_to_ijk[Kpb,2]
                k_pt = k_pts[iN,jN,kN,:]
                wKpb, vKpb = eigh(Ham(a,t,l_nu,l_R,l_SO,[k_pt[0], k_pt[1]]))

                #Compute the overlap at points K and Kpb,
                #and write it to mmn file
                disp_vec = [0, 0, 0]
                if(N1>1):
                    if((i==0) & (iN == N1-1)): 
                        disp_vec[0] = -1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                    if((i==N1-1) & (iN == 0)):
                        disp_vec[0] = 1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                if(N2>1):
                    if((j==0) & (jN == N2-1)): 
                        disp_vec[1] = -1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                    if((j==N2-1) & (jN == 0)):
                        disp_vec[1] = 1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                if(N3>1):
                    if((k==0) & (kN == N3-1)): 
                        disp_vec[2] = -1
                    if((k==N3-1) & (kN == 0)):
                        disp_vec[2] = 1

                mmn.write(str(K+1) + '       ' + str(Kpb+1)+' '+ str(disp_vec[0]) + ' ' + str(disp_vec[1])+ ' ' + str(disp_vec[2]) + '\n')# TODO this should have the displacement vector

                for mn in range(nband**2):
                    m,n = mod(mn,nband), int(mn/nband)
                    overlap = dot(conj(vK[:,m]),vKpb[:,n]) 
                    mmn.write(str(real(overlap)) + '    ' + str(imag(overlap)) + '\n')
    

mmn.close()
amn.close()

win = open("kanemele_"+str(l_nu)+"_"+str(N1)+".win",'w')
win.write("""num_bands         =   2
num_wann          =   2
num_iter          = 500
num_print_cycles  = 1

bands_plot	  = true
wannier_plot	  = true
auto_proj	  = false

begin unit_cell_cart 
bohr
""")

win.write(str(2*pi) + " 0 0\n")
win.write("0 " + str(2*pi) + " 0\n")
win.write("0 0 " + str(2*pi) + "\n")
win.write("""end unit_cell_cart

""")

win.write("mp_grid      = " + str(N1) + " " + str(N2) + " " + str(N3) + "\n")
win.write("begin kpoints\n")

t1 = [i/N1 for i in range(N1)]
t2 = [i/N2 for i in range(N2)]
t3 = [i/N3 for i in range(N3)]

for i in range(N1): 
    for j in range(N2): 
        for k in range(N3):
	    t1_ = floor(t1[i]*10000)/10000. 
	    t2_ = floor(t2[j]*10000)/10000. 
	    t3_ = floor(t3[k]*10000)/10000. 
	    win.write(str(t1_) + " " + str(t2_) + " "  + str(t3_) + "\n")

win.write("end kpoints\n")

win.close()


if(PLOT_EIG):
    #Plot eigenvalue surfaces
    fig = plt.figure()
    ax = fig.gca(projection='3d')
    
    X, Y = meshgrid(range(N1),range(N2))
    Z = zeros((N1,N2,4))
    for i in range(N1):
        for j in range(N2):
            for n in range(4):
                Z[i,j,n] = eigs[X[i,j],Y[i,j],0,n]
    
    for n in range(4):
        ax.plot_surface(X,Y,Z[:,:,n])
    
    l_nu_val = bool(l_nu>3*sqrt(3))*"+ " + bool(l_nu!=3*sqrt(3))*str(l_nu - 3*sqrt(3))
    plt.title("Eigenvalues of the Hamiltonian, l_nu = l_nu,c " +l_nu_val)
    l_nu_readable = str(int(l_nu*100)/100.)
    
    plt.savefig("eigenvalues_ham_"+l_nu_readable+".pdf")


